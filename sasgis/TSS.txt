Секционирование хранилища (шардинг) имеет своей целью разделение единого хранилища между несколькими серверами БД.
В частном случае разные секции могут находиться и на одном сервере БД, например, в разных базах.
В общем случае секции хранилища могут физически располагаться на СУБД разного типа и на разных компьютерах.

Секционирование хранилища необходимо в следующих случаях:
а) СУБД поддерживает резервное копирование и восстановление резервных копий только базы целиком,
   тогда как необходимо для различных частей сервиса обеспечить различную политику сохранности;
б) в случае нехватки места, если часть данных должна быть доступна всегда (локально), а часть данных
   может быть временно недоступна или доступна по локальной сети (в лес с ноутбуком);
в) в прочих аналогичных ситуациях.

Под удалёнными таблицами, объектами, БД, серверами и т.п. понимаются нелокальные сущности (remote), а не подвергнутые удалению (deleted).

Некоторые СУБД имеют встроенные возможности распределения таблиц между сущностями, подлежащими архивированию/восстановлению.
Например MSSQL позволяет выполнять команды BACKUP и RESTORE не только для всей БД, но и для отдельных файлов и файлгрупп.
Sybase ASE такого не позволяет, однако оба они допускают архивирование/восстановление отдельной таблицы (см. bcp).
Если встроенной функциональности СУБД достаточно (если сервер один, только нужна разная политика BACKUP-ов) - рекомендуется пользоваться ей.

Некоторые СУБД имеют встроенные возможности прозрачной связи между серверами, так что можно обращениями к одной БД создавать таблицы на других серверах.
Например, если для Sybase ASE при создании таблицы указать at 'servername.dbname.dbo.tablename' - таблица будет создана на удалённом сервере,
и никаких важных для нас особенностей (или отличий от обычных таблиц) в плане работы с ней не будет.
Если СУБД позволяет обойтись подобными средствами - рекомендуется пользоваться ими.
В примере с Sybase ASE функциональность удалённых таблиц практически полностью покрывает все описанные потребности (за исключением настройки области).
В частности, удалённым сервером может быть и локальный, что обеспечит хранение некоторых таблиц в другой БД.
Если удалённый сервер (или БД на нём, или таблица в БД) недоступен, то недоступными будут только эти данные, локальный сервер будет работать.
Архивация (DUMP DATABASE) и восстановление (LOAD DATABASE + ONLINE DATABASE) удалённой БД выполняются отдельно.

Также если есть возможность локализовать различные версии снимков, то рекомендуется просто напросто создать несколько разных сервисов.
Например для DigitalGlobe (Nokia, Decarta и т.п.) рекомендуется выделять область для обособленного хранения не через секционирование,
а созданием стольких разных zmp, сколько необходимо физически разных хранилищ.

Во всех случаях секционирование предполагает определение места хранения конечного объекта (тайла) по его координатам.
Определение осуществляется либо по тайловым координатам, либо по табличным. Описание всех секций хранилища задаётся в файле INI в исходной (первичной) секции.

Под тайловыми координатами понимается совокупность {Z, X, Y}.
Настройка области для секции по ZXY означает принципиальную возможность того, что тайлы в одной таблице должны будут храниться на разных серверах.
Между тем встроенные реализации удалённых таблиц не подразумевают такой возможности.
Таким образом, при настройке секционирования по тайловым координатам либо необходимо выполнять секционирование (шардинг) вручную, либо локальное и
удалённое имена одной и той же таблицы должны различаться.
Первый вариант реализован как Ручное секционирование.
К варианту с изменением имени таблицы при её проксировании мы может быть когда-нибудь и вернёмся, но пока он не представляется сколько-нибудь выигрышным.

Под табличными координатами понимается совокупность {Z, HighX, HighY}, последние значения формируются на основании режима деления тайлов на таблицы.
Настроенное таким образом секционирование очевидно обладает тем свойством, что таблица целиком находится на одном сервере БД.
В этом случае допустимо использование встроенной реализации удалённых таблиц (если таковая имеется для СУБД).
Так как все тайлы хранятся на одном сервере, а прокси-таблица для них находится на другом сервере, противоречий не возникает.
Впрочем отсюда сразу следует главное ограничение такого метода - области определения секций на средних зумах получаются очень большими.
Зато так как чтение всех без исключения тайлов доступно в рамках одной рабочей БД (для удалённых таблиц используются прокси-таблицы),
карта заполнения строится в этом случае как прежде, изменений в алгоритм её построения не требуется.
Так как настройка секционирования в этом случае важна в момент создания таблицы для хранения тайлов, необходимо в этот момент формировать правильный текст SQL.
Для этого предусмотрена возможность вызова хранимой процедуры или функции (в зависимости от СУБД), которая должна вернуть перечень всех модификаций,
которые необходимо выполнить для скрипта создания таблицы по умолчанию (из таблицы Z_ALL_SQL).
Таким образом этот вариант можно условно назвать Процедурное секционирование.

Возможен также вариант, при котором области определения секций задаются в табличных координатах, но при этом секционировани выполняется в Ручном режиме.
Однако он не имеет преимуществ перед Ручным секционированием в тайловых координатах, так как при прочих равных условиях является сильно более грубым.
Таким образом он не реализован.

Встроенная реализация удалённых таблиц как правило имеет своим ограничением идентичность типов СУБД (не для всех пар СУБД существуют прозрачные шлюзы).
Таким образом с уверенностью можно говорить, что встроенная реализация удалённых таблиц работает только между одинаковыми СУБД.
Тогда как Ручная реализация секционирования не имеет никаких ограничений для исполнения в гетерогенной среде. Могут использоваться все поддерживаемые типы СУБД.

На каждую секцию хранилища создаётся отдельное подключение к СУБД. Соответственно первичная секция определяет первичное подключение, вторичная - вторичное, и т.п.

Предполагается, что метаданные (параметры сервиса, версии, справочники и т.п.) хранятся только в одной секции (настраиваемо).
Это допустимо, так как таблицы с тайлами не содержат ограничений ссылочной целостности по отношению к таблицам сервисов и версий.
Хранить метаданные можно как в первичной секции, так и в самой первой из вторичных секций. Прочие варианты (например указание секции по имени) не поддерживаются.

Таким образом функциональность секционирования не подразумевает тиражирование одного тайла между несколькими секциями (базами).
Также она не связана с репликацией и кластеризацией, и не использует триггеры.

Нумерация зумов начинается с 1.

Так как тайловые координаты (а через них и табличные) для разных проекций могут соответствать разным географическим координатам,
для разных сервисов в разных проекциях может потребоваться различная настройка областей секций (в зависимости от потребностей).

На созданном и функционирующем хранилище менять параметры секционирования в общем случае нельзя, так как это может привести
к изменению расположения тайловых таблиц между серверами. В итоге данные будут недоступны.
Относительно безопасными являются операции:
а) инверсии первичной и вторичной секций в случае двух секций - для этого надо поменять местами секции,
   при необходимости установить секцию для справочников, а также заменить $TSS_Mode с 1 на 2 (или наоборот).
б) добавления новой секции с областью вне существующего покрытия без безусловно попадающих в неё зумов.

В общем случае для корректной модификации настроек секционирования необходимо:
а) создать новые настройки с НОВЫМИ именами секций как НОВОЕ отдельное хранилище;
б) выполнить перенос кэша из одного хранилища в другое (из старого в новое);
в) при необходимости выполнить корректный перенос версий тайлов (дат, описаний и прочих метаданных).





Возможности некоторых СУБД:

MSSQL:
а) BACKUP и RESTORE работают по целой БД либо по отдельным файлам и файлгруппам;
б) размер БД можно уменьшить;
в) встроенная функциональность связи между серверами на OLEDB работает очень медленно;
г) возможно использование CREATE SYNONYM tablename FOR servername.dbname.dbo.tablename

Sybase ASE:
а) DUMP и LOAD работают только для БД целиком;
б) нельзя уменьшить размер БД;
в) сохранение и восстановление части БД возможно либо через bcp, либо через копирование тайлов между хранилищами в SAS;
г) Существует CIS (Component Integration Services) и create table tablename () at 'servername.dbname.dbo.tablename'.

PostgreSQL:
а) возможности FOREIGN TABLE/DATA крайне скудны, фактически встроенная функциональность отсутствует,
   необходимо использование сторонних разработок, по сути через сторонние серверы приложений.
б) архивирование и восстановление возможны для любого перечня таблиц и для БД целиком.





Пример 1 для Sybase ASE.

[GOOGLETEST\$]
DSN=GIS
UID=sa
PWD=123456
$ODBC_ConnectWithParams=0
$SYNC_SQL_MODE=0

$TSS_ProcedureNew=sas_sp_new_object_sql

$TSS_Code=8
$TSS_Dest=ASEMAIN_ODBC\$
$TSS_Area=Z15,L10,T4,R11,B5
$TSS_Zoom=15-19
$TSS_Full=1-14
$TSS_Mode=2

[ASEMAIN_ODBC\$]
DSN=ASEMAIN_ODBC
UID=sa
PWD=123456
$ODBC_ConnectWithParams=0
$SYNC_SQL_MODE=0


В этом примере описано Процедурное секционирование на основе табличных координат.
Определено 2 секции на 2 разных серверах (DSN).
Первичной секцией является GOOGLETEST\$ - в zmp указывается NameinCache=GOOGLETEST\$\googlesat (или нечто аналогичное по сути).
Вторичной секцией является ASEMAIN_ODBC\$.

В первичной секции набор параметров, начинающихся на '$TSS_', относится к секционированию.
Все прочие параметры являются стандартными общими, и здесь не рассматриваются.
Также в этом примере нет настройки расположения справочников во вторичной секции, поэтому все справочники располагаются только в первичной секции.

Из всех параметров секционирования особняком стоит $TSS_ProcedureNew.
Этот параметр указывается в секции только один раз, и распространяется на все вторичные секции, если их несколько.
Если он не указан, или указано пустое значение - подразумевается Ручное секционирование по тайловыхм координатам.
Если значение параметра указано - оно трактуется как имя хранимой процедуры (или функции, в зависимости от СУБД) для секционирования.
В данном примере для Sybase ASE sas_sp_new_object_sql - это имя хранимой процедуры.
Вызов процедуры выполняется ТОЛЬКО в первичной секции (на первичном подключении).

Прочие параметры секционирования можно указывать с уникальным суффиксом, например, $TSS_Dest1 или $TSS_FullXXX.
В этом случае к одной секции относятся параметры с одинаковым суффиксом, для пропущенных параметров используются значения по умолчанию.

Единственным обязательным параметров секционирования является $TSS_Dest, который задаёт секцию подключения.
Таким образом, число секций (кроме первичной) определяется числом различных суффиксов у параметра $TSS_Dest в рамках первичной секции.
В примере суффикс пустой.

Параметр $TSS_Code задаёт значение параметра для исполнения процедуры секционирования.
Это сделано для возможности различать разные секции в рамках одной процедуры.

Если параметр $TSS_Code опущен, имеет нецелочисленное значение или ноль - процедура не вызывается,
а секционирование для данной конкретной вторичной секции выполняется как будто вручную.
Это послабление предусмотрено для создания смешанной схемы секционирования, в которой использование встроенной реализации секционирования для части секций
сочетается с ручным секционированием для других СУБД других типов. Без особой причины пользоваться этой возможностю не рекомендуется.

Параметры $TSS_Area и $TSS_Zoom работают в паре. Если хотя бы один отсутствует - второй игнорируется.
Первый определяет прямоугольную область секции, а второй - для каких зумов тайлы попадают в эту секцию.
В примере область определена на 15-м зуме через значения L(eft), T(op), R(ight) и B(ottom).
Область задаётся двумерным полуинтервалом: нижняя граница Top и Left включается в область, а верхняя граница Right и Bottom исключается из области.
То есть в примере область секции - это область, покрываемая одной таблицей на 15 зуме с табличными координатами (10,4).
В реальности это область 2x2 тайла на 8 зуме с (20,8) по (21,9) включительно (для настройки деления тайлов по таблицам по умолчанию).

Параметр $TSS_Full определяет зумы, тайлы на которых независимо от их координат попадают в указанную секцию.
Таким образом в данном примере тайлы, попадающие в условие секционирования - это все тайлы на зумах 1-14 и тайлы в указанной области на зумах 15-19.
Перечень зумов во всех случаях можно задавать также через запятую, например $TSS_Zoom=8,10,12,14-16,18,19.

Параметр $TSS_Mode может иметь 3 значения:
0 - секция отключена.
1 - секция включена.
2 - значение алгоритма инвертируется.

В данном примере указано значение $TSS_Mode=2.
Это означает, что все тайлы, НЕ попадающие в условие секционирования - наоборот попадут в секцию ASEMAIN_ODBC\$.
А тайлы, попадающие в условие секционирования, в реальности НЕ будут попадать в секцию ASEMAIN_ODBC\$, поиск секции продолжится,
и в конце они попадут в первичную, так как они не попали в результате ни в одну из секций.

Осталось рассмотреть хранимую процедуру sas_sp_new_object_sql.
Её задача - вернуть набор данных для модификации скрипта по умолчанию (который берётся из Z_ALL_SQL).
В настоящий момент возможность "подправить" текст создаваемой процедуры доступна ТОЛЬКО для тайловых таблиц и только для Процедурного секционирования.
Тем не менее даже для тайловых таблиц в Z_ALL_SQL хранится более одного скрипта, поэтому проверка номера скрипта является обязательной.

Вот текст процедуры (напоминаю, выполняется она ТОЛЬКО при создании НОВЫХ отсутствующих таблиц):

create procedure sas_sp_new_object_sql
@index_sql smallint,
@object_oper char,
@object_name varchar(255),
@section_code int
as
begin
  set nocount on
  
  if (8=@section_code) and (1=@index_sql) and ('C'=@object_oper) begin
    -- at linked server MAIN
    select 'A' as txt_mod, 0 as txt_pos, ' at ''ASEMAIN.sas_ase.dbo.[' + @object_name + ']''' as txt_sql
  end
  return(0)
end

Суть проверки в процедуре предельно проста:
а) если номер секции равен 8 (этот номер задаётся в файле INI);
б) и если номер скрипта равен 1 (этот номер задаётся в таблице Z_ALL_SQL);
в) и если это создание таблицы (код операции 'C' = Create),

то тогда возвращаем, что надо добавить в конец (код операции 'A' = Append) текст вида:
at 'ASEMAIN.sas_ase.dbo.[@object_name]'
причём полное удалённое имя таблицы формируется как строка, а значение @object_name подставляется из параметров.

Также небходимо будет создать Remote Server ASEMAIN и БД sas_ase на нём, чтобы это всё работало.
Все прочие подробности этого, как зарегистрировать сервер в DSEdit, как его добавить в master..sysservers, и т.п. описаны в манулах к Sybase ASE.





Пример 2 для MSSQL.

[MSSQL_YANDEX\$]
$ODBC_ConnectWithParams=1
$SYNC_SQL_MODE=0
DRIVER={SQL Server Native Client 10.0}
SERVER=LOCALHOST
Database=sas_rf
trusted_connection=yes
Mars_Connection=yes

$TSS_Dest=MSSQL_YANDEX_P40\$
$TSS_Area=Z8,L83,T35,R86,B38
$TSS_Zoom=10-20
$TSS_Full=1-9

$GUIDES_LINK=Secondary

[MSSQL_YANDEX_P40\$]
$ODBC_ConnectWithParams=1
$SYNC_SQL_MODE=0
DRIVER={SQL Server Native Client 10.0}
SERVER=LOCALHOST
Database=sas_ms
trusted_connection=yes
Mars_Connection=yes

В этом примере описано Ручное секционирование для одной первичной секции (MSSQL_YANDEX\$) и одной вторичной (MSSQL_YANDEX_P40\$).
Обе секции физически располагаются на одном сервере LOCALHOST, но в разных БД (первая - в sas_rf, вторая - в sas_ms).
Подключение к обеим секциям осуществляется не через System DSN, а через строку подключения (ConnectionString),
которая формируется на основе параметров (данное поведение включается параметром $ODBC_ConnectWithParams=1).
Различные варианты формирования ConnectionString для различных СУБД при подключении через ODBC можно поглядеть
на сайте http://connectionstrings.com/.

Параметр $GUIDES_LINK имеет значение Secondary - это означает, что справочники хранятся на первой (в данном случае на единственной) вторичной секции (MSSQL_YANDEX_P40\$).

Параметры $TSS_Dest и $TSS_Full полностью аналогичны Примеру 1. То есть имя вторичной секции и зумы, которые в неё безусловно попадают целиком.

Параметры $TSS_Area и $TSS_Zoom, как и в Примере 1, "работают" в паре.
Только в этом примере (ввиду отсутствия параметра $TSS_ProcedureNew и параметров $TSS_Code) секционирование Ручное, в тайловых координатах.
То есть областью секции является прямоугольник на 8 зуме из тайлов с (83,35) по (85,37) включительно - то есть квадрат из 9 тайлов на 8 зуме.
Соответственно в рамках этой области в секцию попадают зумы 10-20 (всё что выше попадает безусловно, всё что ниже - вообще не попадает).

Так как параметр $TSS_Mode отсутствует, его значение принимается равным значению по умолчанию - 1 (секция включена).