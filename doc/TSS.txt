Секционирование хранилища (шардинг) имеет своей целью разделение единого хранилища между несколькими серверами БД.
В частном случае разные секции могут находиться и на одном сервере БД, например, в разных базах.
В общем случае секции хранилища могут физически располагаться на СУБД разного типа и на разных компьютерах.

Секционирование хранилища необходимо в следующих случаях:
а) СУБД поддерживает резервное копирование и восстановление резервных копий только базы целиком,
   тогда как необходимо для различных частей сервиса обеспечить различную политику сохранности;
б) в случае нехватки места, если часть данных должна быть доступна всегда (локально), а часть данных
   может быть временно недоступна или доступна по локальной сети (в лес с ноутбуком);
в) в прочих аналогичных ситуациях.

Под удалёнными таблицами, объектами, БД, серверами и т.п. понимаются нелокальные сущности (remote), а не подвергнутые удалению (deleted).

Некоторые СУБД имеют встроенные возможности распределения таблиц между сущностями, подлежащими архивированию/восстановлению.
Например MSSQL позволяет выполнять команды BACKUP и RESTORE не только для всей БД, но и для отдельных файлов и файлгрупп.
Sybase ASE такого не позволяет, однако оба они допускают архивирование/восстановление отдельной таблицы (см. bcp).
Если встроенной функциональности СУБД достаточно (если сервер один, только нужна разная политика BACKUP-ов) - рекомендуется пользоваться ей.

Некоторые СУБД имеют встроенные возможности прозрачной связи между серверами, так что можно обращениями к одной БД создавать таблицы на других серверах.
Например, если для Sybase ASE при создании таблицы указать at 'servername.dbname.dbo.tablename' - таблица будет создана на удалённом сервере,
и никаких важных для нас особенностей (или отличий от обычных таблиц) в плане работы с ней не будет.
Если СУБД позволяет обойтись подобными средствами - рекомендуется пользоваться ими.
В примере с Sybase ASE функциональность удалённых таблиц практически полностью покрывает все описанные потребности (за исключением настройки области).
В частности, удалённым сервером может быть и локальный, что обеспечит хранение некоторых таблиц в другой БД.
Если удалённый сервер (или БД на нём, или таблица в БД) недоступен, то недоступными будут только эти данные, локальный сервер будет работать.
Архивация (DUMP DATABASE) и восстановление (LOAD DATABASE + ONLINE DATABASE) удалённой БД выполняются отдельно.

Также если есть возможность локализовать различные версии снимков, то рекомендуется просто напросто создать несколько разных сервисов.
Например для DigitalGlobe (Nokia, Decarta и т.п.) рекомендуется выделять область для обособленного хранения не через секционирование,
а созданием стольких разных zmp, сколько необходимо физически разных хранилищ.

Во всех случаях секционирование предполагает определение места хранения конечного объекта (тайла) по его координатам.
Определение осуществляется либо по тайловым координатам, либо по табличным. Описание всех секций хранилища задаётся в файле INI в исходной (первичной) секции.

Под тайловыми координатами понимается совокупность {Z, X, Y}.
Настройка области для секции по ZXY означает принципиальную возможность того, что тайлы в одной таблице должны будут храниться на разных серверах.
Между тем встроенные реализации удалённых таблиц не подразумевают такой возможности.
Таким образом, при настройке секционирования по тайловым координатам либо необходимо выполнять секционирование (шардинг) вручную, либо локальное и
удалённое имена одной и той же таблицы должны различаться.
Первый вариант реализован как Ручное секционирование.
К варианту с изменением имени таблицы при её проксировании мы может быть когда-нибудь и вернёмся, но пока он не представляется сколько-нибудь выигрышным.

Под табличными координатами понимается совокупность {Z, HighX, HighY}, последние значения формируются на основании режима деления тайлов на таблицы.
Настроенное таким образом секционирование очевидно обладает тем свойством, что таблица целиком находится на одном сервере БД.
В этом случае допустимо использование встроенной реализации удалённых таблиц (если таковая имеется для СУБД).
Так как все тайлы хранятся на одном сервере, а прокси-таблица для них находится на другом сервере, противоречий не возникает.
Впрочем отсюда сразу следует главное ограничение такого метода - области определения секций на средних зумах получаются очень большими.
Зато так как чтение всех без исключения тайлов доступно в рамках одной рабочей БД (для удалённых таблиц используются прокси-таблицы),
карта заполнения строится в этом случае как прежде, изменений в алгоритм её построения не требуется.
Так как настройка секционирования в этом случае важна в момент создания таблицы для хранения тайлов, необходимо в этот момент формировать правильный текст SQL.
Для этого предусмотрена возможность вызова хранимой процедуры или функции (в зависимости от СУБД), которая должна вернуть перечень всех модификаций,
которые необходимо выполнить для скрипта создания таблицы по умолчанию (из таблицы Z_ALL_SQL).
Таким образом этот вариант можно условно назвать Процедурное секционирование.

Возможен также вариант, при котором области определения секций задаются в табличных координатах, но при этом секционировани выполняется в Ручном режиме.
Однако он не имеет преимуществ перед Ручным секционированием в тайловых координатах, так как при прочих равных условиях является сильно более грубым.
Таким образом он не реализован.

Встроенная реализация удалённых таблиц как правило имеет своим ограничением идентичность типов СУБД (не для всех пар СУБД существуют прозрачные шлюзы).
Таким образом с уверенностью можно говорить, что встроенная реализация удалённых таблиц работает только между одинаковыми СУБД.
Тогда как Ручная реализация секционирования не имеет никаких ограничений для исполнения в гетерогенной среде. Могут использоваться все поддерживаемые типы СУБД.

Также необходимо отметить, что соединения между серверами БД не могут программно контролироваться, они требуют отдельной настройки,
могут подвисать при недоступности сервера, и т.п. - соответственно ожидаемый таймаут по ним может быть существенно превышен.
При Ручной реализации все подключения создаются программно, все доступные настройки для них могут быть установлены пользователем, и такой проблемы не существует.
Таким образом в большинстве случаев рекомендуется использовать Ручную реализацию секционирования.

На каждую секцию хранилища создаётся отдельное подключение к СУБД. Соответственно первичная секция определяет первичное подключение, вторичная - вторичное, и т.п.

Предполагается, что метаданные (параметры сервиса, версии, справочники и т.п.) хранятся только в одной секции (настраиваемо).
Это допустимо, так как таблицы с тайлами не содержат ограничений ссылочной целостности по отношению к таблицам сервисов и версий.
Хранить метаданные можно как в первичной секции, так и в самой первой из вторичных секций. Прочие варианты (например указание секции по имени) не поддерживаются.

Таким образом функциональность секционирования не подразумевает тиражирование одного тайла между несколькими секциями (базами).
Также она не связана с репликацией и кластеризацией, и не использует триггеры.

Нумерация зумов начинается с 1.

Так как тайловые координаты (а через них и табличные) для разных проекций могут соответствать разным географическим координатам,
для разных сервисов в разных проекциях может потребоваться различная настройка областей секций (в зависимости от потребностей).

На созданном и функционирующем хранилище менять параметры секционирования в общем случае нельзя, так как это может привести
к изменению расположения тайловых таблиц между серверами. В итоге данные будут недоступны.
Относительно безопасными являются операции:
а) инверсии первичной и вторичной секций в случае двух секций - для этого надо поменять местами секции,
   при необходимости установить секцию для справочников, а также заменить $TSS_Mode с 1 на 2 (или наоборот).
б) добавления новой секции с областью вне существующего покрытия без безусловно попадающих в неё зумов.

В общем случае для корректной модификации настроек секционирования необходимо:
а) создать новые настройки с НОВЫМИ именами секций как НОВОЕ отдельное хранилище;
б) выполнить перенос кэша из одного хранилища в другое (из старого в новое);
в) при необходимости выполнить корректный перенос версий тайлов (дат, описаний и прочих метаданных).





Возможности некоторых СУБД:

MSSQL:
а) BACKUP и RESTORE работают по целой БД либо по отдельным файлам и файлгруппам;
б) размер БД можно уменьшить;
в) встроенная функциональность связи между серверами на OLEDB работает очень медленно;
г) возможно использование CREATE SYNONYM tablename FOR servername.dbname.dbo.tablename

Sybase ASE:
а) DUMP и LOAD работают только для БД целиком;
б) нельзя уменьшить размер БД;
в) сохранение и восстановление части БД возможно либо через bcp, либо через копирование тайлов между хранилищами в SAS;
г) Существует CIS (Component Integration Services) и create table tablename () at 'servername.dbname.dbo.tablename'.

PostgreSQL:
а) возможности FOREIGN TABLE/DATA крайне скудны, фактически встроенная функциональность отсутствует,
   необходимо использование сторонних разработок, по сути через сторонние серверы приложений.
б) архивирование и восстановление возможны для любого перечня таблиц и для БД целиком.





Пример 1 для Sybase ASE.

[GOOGLETEST\$]
DSN=GIS
UID=sa
PWD=123456
$ODBC_ConnectWithParams=0
$SYNC_SQL_MODE=0

$TSS_Algorithm=Linked
$TSS_NewTileTable_Proc=sas_sp_new_object_sql
$TSS_NewTileTable_Link=Primary
$TSS_Guides_Link=Primary
$TSS_Undefined_Link=Primary

$TSS_Code=8
$TSS_Dest=ASEMAIN_ODBC\$
$TSS_Area=Z15,L10,T4,R11,B5
$TSS_Zoom=15-19
$TSS_Full=1-14
$TSS_Mode=2

[ASEMAIN_ODBC\$]
DSN=ASEMAIN_ODBC
UID=sa
PWD=123456
$ODBC_ConnectWithParams=0
$SYNC_SQL_MODE=0


В этом примере описано секционирование с использованием уладённых таблиц (процедурное) на основе табличных координат.
Определено 2 секции на 2 разных серверах (System DSN).
Подключение осуществляется без использования параметров (используются только значения параметров DSN, UID и PWD).
Первичной секцией является GOOGLETEST\$ - в zmp указывается NameinCache=GOOGLETEST\$\googlesat (или нечто аналогичное по сути).
Вторичной секцией является ASEMAIN_ODBC\$.

В первичной секции набор параметров, начинающихся на '$TSS_', относится к секционированию.

Ряд параметров определяют используемую секцию (используемое подключение) и задаются схожим образом.
Это параметры с именами $TSS_*_Link.
Возможные значения - Primary и Secondary.
Если указано Secondary - значит используется вторичное подключение.
Иначе будет использоваться первичное подключение (значение по умолчанию).
Конкретный смысл каждого такого параметра будет описан дальше.

Параметр $TSS_Algorithm определяет общий алгоритм секционирования.
Значение Linked как раз и указывает, что будет использоваться встроенная функциональность удалённых таблиц, для которой сервера
должны быть связаны между собой.
Этот параметр ДОЛЖЕН быть первым среди всех параметров TSS в первичной секции.

Параметр $TSS_NewTileTable_Proc определяет имя хранимой процедуры или функции, которая будет использоваться для корректного
формирования скрипта создания тайловых таблиц.
Для случая $TSS_Algorithm=Linked этот параметр является ОБЯЗАТЕЛЬНЫМ.
Без подобной процедуры формирование правильного скрипта создания таблицы возможно только на основе таблицы Z_ALL_SQL, что
сильно выходит за рамки данного общего описания (хотя это и возможно).

Параметр $TSS_NewTileTable_Link определяет, где находится процедура $TSS_NewTileTable_Proc.
То есть буквально - какое подключение будет использоваться для её запуска.
В примере указано использовать первичное подключение (первичную секцию).

Параметр $TSS_Guides_Link определяет, какое подключение будет использоваться для справочников, чтения свойств сервисов и т.п.
В примере указано использовать первичное подключение (первичную секцию).

Параметр $TSS_Undefined_Link определяет, к какой секции будут отнесены тайлы, которые не попали ни в одну из секций (по условию).
В примере указано использовать для непопавших никуда тайлов первичное подключение (первичную секцию).

Прочие параметры секционирования можно указывать с уникальным суффиксом, например, $TSS_Dest1 или $TSS_FullXXX.
В этом случае к одной секции относятся параметры с одинаковым суффиксом, для пропущенных параметров используются значения по умолчанию.

Единственным обязательным параметров секционирования является $TSS_Dest, который задаёт секцию подключения.
Таким образом, число секций (кроме первичной) определяется числом различных суффиксов у параметра $TSS_Dest в рамках первичной секции.
В примере суффикс пустой.

Параметр $TSS_Code задаёт значение параметра для исполнения процедуры секционирования.
Это сделано для возможности различать разные секции в рамках одной процедуры.

Если параметр $TSS_Code опущен, имеет нецелочисленное значение или ноль - процедура не вызывается,
а секционирование для данной конкретной вторичной секции выполняется как будто вручную.
Это послабление предусмотрено для создания смешанной схемы секционирования, в которой использование встроенной реализации секционирования для части секций
сочетается с ручным секционированием для других СУБД других типов. Без особой причины пользоваться этой возможностю не рекомендуется.

Параметры $TSS_Area и $TSS_Zoom работают в паре. Если хотя бы один отсутствует - второй игнорируется.
Первый определяет прямоугольную область секции, а второй - для каких зумов тайлы попадают в эту секцию.
В примере область определена на 15-м зуме через значения L(eft), T(op), R(ight) и B(ottom).
Область задаётся двумерным полуинтервалом: нижняя граница Top и Left включается в область, а верхняя граница Right и Bottom исключается из области.
То есть в примере область секции - это область, покрываемая одной таблицей на 15 зуме с табличными координатами (10,4).
В реальности это область 2x2 тайла на 8 зуме с (20,8) по (21,9) включительно (для настройки деления тайлов по таблицам по умолчанию).

Параметр $TSS_Full определяет зумы, тайлы на которых независимо от их координат попадают в указанную секцию.
Таким образом в данном примере тайлы, попадающие в условие секционирования - это все тайлы на зумах 1-14 и тайлы в указанной области на зумах 15-19.
Перечень зумов во всех случаях можно задавать также через запятую, например $TSS_Zoom=8,10,12,14-16,18,19.

Параметр $TSS_Mode может иметь 3 значения:
0 - секция отключена.
1 - секция включена (значение по умолчанию).
2 - значение алгоритма инвертируется.

В данном примере указано значение $TSS_Mode=2.
Это означает, что все тайлы, НЕ попадающие в условие секционирования - наоборот попадут в секцию ASEMAIN_ODBC\$.
А тайлы, попадающие в условие секционирования, в реальности НЕ будут попадать в секцию ASEMAIN_ODBC\$, поиск секции продолжится,
и в конце они попадут в первичную, так как они не попали в результате ни в одну из секций (см. параметр $TSS_Undefined_Link).

Осталось рассмотреть хранимую процедуру sas_sp_new_object_sql.
Её задача - вернуть набор данных (не более 5 полей, число записей не регламентируется) для модификации скрипта (который берётся из Z_ALL_SQL).
В настоящий момент возможность "подправить" текст создаваемой процедуры доступна ТОЛЬКО для тайловых таблиц.
Тем не менее даже для тайловых таблиц в Z_ALL_SQL хранится более одного скрипта, поэтому проверка номера скрипта является обязательной.

Вот текст процедуры (выполняется она ТОЛЬКО при создании НОВЫХ отсутствующих таблиц):

create procedure sas_sp_new_object_sql
@index_sql smallint,
@object_oper char,
@object_name varchar(255),
@section_code int
as
begin
  set nocount on
  
  if (8=@section_code) and (1=@index_sql) and ('C'=@object_oper) begin
    -- at linked server MAIN
    select 'A' as txt_mod, 0 as txt_pos, ' at ''ASEMAIN.sas_ase.dbo.[' + @object_name + ']''' as txt_sql
  end
  return(0)
end

Суть проверки в процедуре предельно проста:
а) если номер секции равен 8 (этот номер задаётся в файле INI);
б) и если номер скрипта равен 1 (этот номер задаётся в таблице Z_ALL_SQL);
в) и если это создание таблицы (код операции 'C' = Create).

И если эта проверка выполнена удачно, то тогда возвращаем, что надо добавить в конец (код операции 'A' = Append) текст вида:
at 'ASEMAIN.sas_ase.dbo.[@object_name]'
причём полное удалённое имя таблицы формируется как строка, а значение @object_name подставляется из параметров.

Также небходимо будет создать Remote Server ASEMAIN и БД sas_ase на нём, чтобы это всё работало.
Все прочие подробности этого, как зарегистрировать сервер в DSEdit, как его добавить в master..sysservers, и т.п. описаны в манулах к Sybase ASE.





Пример 2 для MSSQL.

[MSSQL_YANDEX\$]
$ODBC_ConnectWithParams=1
$SYNC_SQL_MODE=0
DRIVER={SQL Server Native Client 10.0}
SERVER=LOCALHOST
Database=sas_rf
trusted_connection=yes
Mars_Connection=yes

$TSS_Algorithm=Manual
$TSS_Guides_Link=Secondary
$TSS_Undefined_Link=Primary

$TSS_Dest_2=MSSQL_YANDEX_P40\$
$TSS_Area_2=Z8,L83,T35,R86,B38
$TSS_Zoom_2=10-20
$TSS_Full_2=1-9

$TSS_Dest_1=MSSQL_YANDEX_MSK\$
$TSS_Area_1=Z10,L308,T159,R311,B162
$TSS_Zoom_1=10-20

[MSSQL_YANDEX_P40\$]
$ODBC_ConnectWithParams=1
$SYNC_SQL_MODE=0
DRIVER={SQL Server Native Client 10.0}
SERVER=LOCALHOST
Database=sas_ms
trusted_connection=yes
Mars_Connection=yes

[MSSQL_YANDEX_MSK\$]
$ODBC_ConnectWithParams=1
$SYNC_SQL_MODE=0
DRIVER={SQL Server Native Client 10.0}
SERVER=VSA-MAIN\MAIN_MSSQL
Database=SASGIS_MAIN_DB
trusted_connection=yes
Mars_Connection=yes


В этом примере описано Ручное секционирование для первичной секции MSSQL_YANDEX\$, вторичной секции MSSQL_YANDEX_P40\$ и ещё одной MSSQL_YANDEX_MSK\$.
Две первые секции физически располагаются на одном сервере LOCALHOST, но в разных БД (первая - в sas_rf, вторая - в sas_ms).
Третья секция располагается на другом сервере, здесь это именованный экземпляр VSA-MAIN\MAIN_MSSQL, а в нём БД с именем SASGIS_MAIN_DB.
Подключение ко всем секциям осуществляется не через System DSN, а через строку подключения (ConnectionString),
которая формируется на основе параметров (данное поведение включается параметром $ODBC_ConnectWithParams=1).
Различные варианты формирования ConnectionString для различных СУБД при подключении через ODBC можно поглядеть
на сайте http://connectionstrings.com/.

Параметр $TSS_Algorithm=Manual определяет, что секционирование будет ручное.

В данном примере не используется таблица для секционирования, так что параметры $TSS_NewTileTable_Proc и $TSS_NewTileTable_Link отсутствуют.

Параметр $TSS_Guides_Link имеет значение Secondary - это значит, что справочники хранятся на вторичной секции (MSSQL_YANDEX_P40\$).

Параметр $TSS_Undefined_Link имеет значение Primary - это значит, что непопавшие никуда тайлы будут сохраняться в первичной секции (MSSQL_YANDEX\$).

Прочие параметры TSS имеют суффиксы.
Соответственно значения полей TSS относятся к той секции, чей суффикс указан в имени параметра.
Суффиксы не сортируются, таким образом параметр $TSS_Dest_2 обрабатывается раньше параметра $TSS_Dest_1.
Поэтому вторичной секцией является здесь MSSQL_YANDEX_P40\$.
А секция MSSQL_YANDEX_MSK\$ (и любые другие прочие, которые были бы описаны ниже) - просто одна из секций в цепочке определения секции для тайла.

Параметр $TSS_Dest_2 определяет имя вторичной секции.

Параметры $TSS_Area_2 и $TSS_Zoom_2, как и в Примере 1, "работают" в паре.
Отличие в том, что в этом примере секционирование Ручное, в тайловых координатах.
То есть областью секции является прямоугольник на 8 зуме из тайлов с (83,35) по (85,37) включительно - то есть квадрат из 9 тайлов на 8 зуме.
Соответственно в рамках этой области в секцию попадают зумы 10-20 (всё что выше попадает безусловно, всё что ниже - вообще не попадает).

Параметр $TSS_Full_2 определяет зумы, которые безусловно попадают целиком во вторичную секцию.

Так как параметр $TSS_Mode_2 отсутствует, его значение принимается равным значению по умолчанию - 1 (секция включена).

Далее идут параметры секции с суффиксом '_1'.

Параметр $TSS_Dest_1 определяет имя этой секции.

Параметры $TSS_Area_1 и $TSS_Zoom_1 определяют область секции.
Здесь это прямоугольник на 10 зуме из тайлов с (308,159) по (310,161) включительно - то есть квадрат из 9 тайлов на 10 зуме (вокруг Москвы).

Параметр $TSS_Full_1 отсутствует - поэтому безусловно попадающих в эту секцию зумов нет.

Так как параметр $TSS_Mode_1 отсутствует, его значение принимается равным значению по умолчанию - 1 (секция включена).
